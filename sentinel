#!/bin/bash
[[ $EUID -ne 0 ]] && echo 'This script must be run as root' && exit 255
source ./env.bash

# Check if such process already is running
if [[ -e $PID_FILE && -e /proc/$(cat $PID_FILE) ]]; then
  echo 'Sentinel is already working with pid '$(cat $PID_FILE)
  exit 1
fi

# Prepare folders
test ! -d $WORK_DIR && mkdir $_
test ! -d $TASKS_DIR && mkdir $_

# Workaround variables
declare -A PROCESSES

# Log pid of process
echo $$ > $PID_FILE

load_config() {
  println 'Loading task configs'
  # Clean staff
  unset $PROCESSES
  echo -n > $PIDS_FILE

  # Iterate through all configs
  for file in $(ls $TASKS_DIR); do
    PROCESSES["$file"]=$TASKS_DIR/$file
    source $TASKS_DIR/$file
    test -f $pid_file && cat $_ >> $PIDS_FILE
    test ! -f $WORK_DIR/$file.status && echo 'loading' > $_
  done
  println 'Loaded task configs: '${#PROCESSES[@]}
}

# Print stdout info
println() {
  echo $(date -u '+[%Y-%m-%d %H:%M:%S %Z]')" $1"
}

# Checking system
spawn_checkers() {
  declare -A pids
  for p in ${!PROCESSES[@]}; do
    (
      flock -n 9 || exit 1 # already in progress

      # Set defaults variables for task
      user=$(id -un)
      group=$(id -gn)
      timeout=0

      # Load task config
      source ${PROCESSES[$p]}
      running=$([[ -s $pid_file && -e /proc/$(cat $pid_file) ]] && echo 1 || echo 0)
      status=$([[ "$running" == "1" ]] && echo 'up' || echo 'pending')

      # Save status for current task
      echo $status > $WORK_DIR/$p.status

      # Start process in subshell
      if [[ "$running" == "0" ]]; then
        ((( $timeout > 0 )) && sleep $timeout; echo "$start" | sudo -u $user -g $group bash &)
      fi
    ) 9< ${PROCESSES[$p]} & pids[$p]=$!
  done

  #Check finish of all pids
  for p in ${!pids[@]}; do
    println $p...$(cat $WORK_DIR/$p.status)
  done
}

# Start monitor loop
test -f $RELOAD_FILE && rm -f $_
load_config
while true; do
  # Reload if got new configs and needs
  test -f $RELOAD_FILE &&  rm -f $_ && println 'Reloading task configs signal' && load_config
  test -f $QUIT_FILE && rm -f $_ && println 'Exiting due to quit file' && exit 0
  spawn_checkers
  println '...waiting '$CHECK_TIMEOUT' sec'
  sleep $CHECK_TIMEOUT
done
